/*

2 Построить В дерево, содержащее n = 18 узлов и имеющее степень m = 5 Значения ключей в узлах
задавать с помощью датчика случайных чисел с диапазоном D от 0 до 160
3 Обеспечить обход деревьев «сверху вниз».
4 Выполнить поиск значения ключа по совпадению.

Свойство 1: Глубина всех листьев одинакова.
Свойство 2: Все узлы, кроме корня должны иметь как минимум (m/2) – 1 ключей и максимум m-1 ключей. (2,4)
Свойство 3: Все узлы без листьев, кроме корня (т.е. все внутренние узлы), должны иметь минимум m/2 потомков. (3)
Свойство 4: Если корень – это узел не содержащий листьев, он должен иметь минимум 2 потомка.
Свойство 5:Узел без листьев с n-1 ключами должен иметь n потомков.
Свойство 6: Все ключи в узле должны располагаться в порядке возрастания их значений.
*/

#if 0
void testcase(){
  cout << "\n--------------\nTestCase";
  int test1Arr[18] = {16, 146, 144, 23, 141, 159, 122, 8, 48, 112, 56, 88, 31, 98, 132, 75, 31, 116};
  cout << "\nTest Array: "; outputArray(test1Arr,18);

  BTree testTree(3);
  for(int i = 0; i < 18; i++){
      cout << "Num " << test1Arr[i] << " added, "; 
      testTree.insert(test1Arr[i]);
  }
  cout <<"\nTestBPlusTree is:\n";
  testTree.display();
  cout << "--------------\nTestCase";
}
#endif


